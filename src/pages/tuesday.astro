---
// Tuesday - Type C: Deconstructive / Brutalism | Raw WebGL | Vivid
import { name, fullRole } from '../data/resources';
---

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tuesday | {name}</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Space Grotesk', monospace;
      background: #000;
      color: #fff;
      overflow: hidden;
      min-height: 100vh;
      cursor: crosshair;
    }

    #glCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .brutal-text {
      position: fixed;
      z-index: 2;
      pointer-events: none;
      mix-blend-mode: difference;
    }

    .name-brutal {
      top: 10%;
      right: 5%;
      font-size: clamp(4rem, 12vw, 10rem);
      font-weight: 700;
      line-height: 0.85;
      letter-spacing: -0.05em;
      transform: rotate(-5deg);
      text-shadow:
        3px 3px 0 #ff00ff,
        -3px -3px 0 #00ffff;
      animation: glitch 3s infinite;
    }

    .role-brutal {
      bottom: 15%;
      left: 5%;
      font-size: clamp(1.5rem, 4vw, 3rem);
      font-weight: 700;
      transform: rotate(2deg);
      color: #ff0080;
      text-shadow: 2px 2px 0 #00ff00;
    }

    .nav-brutal {
      position: fixed;
      bottom: 5%;
      right: 5%;
      z-index: 3;
      padding: 1rem 2rem;
      background: #ff0080;
      color: #000;
      text-decoration: none;
      font-weight: 700;
      font-size: 1.2rem;
      border: 3px solid #00ffff;
      transform: skew(-5deg);
      transition: all 0.2s;
    }

    .nav-brutal:hover {
      background: #00ffff;
      border-color: #ff0080;
      transform: skew(-5deg) scale(1.1);
    }

    @keyframes glitch {
      0%, 100% {
        text-shadow:
          3px 3px 0 #ff00ff,
          -3px -3px 0 #00ffff;
      }
      25% {
        text-shadow:
          -3px 3px 0 #ff00ff,
          3px -3px 0 #00ffff;
        transform: rotate(-5deg) translateX(2px);
      }
      50% {
        text-shadow:
          3px -3px 0 #ff00ff,
          -3px 3px 0 #00ffff;
      }
      75% {
        text-shadow:
          -3px -3px 0 #ff00ff,
          3px 3px 0 #00ffff;
        transform: rotate(-5deg) translateX(-2px);
      }
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>

  <div class="brutal-text name-brutal">{name}</div>
  <div class="brutal-text role-brutal">{fullRole}</div>
  <a href="/" class="nav-brutal">HOME</a>

  <script>
    // @ts-nocheck
    // Type C: Brutal WebGL shader with glitch effects
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
      console.error('WebGL not supported');
    }

    // Resize canvas
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    // Vertex shader
    const vsSource = `
      attribute vec4 aVertexPosition;
      void main() {
        gl_Position = aVertexPosition;
      }
    `;

    // Fragment shader with glitch effect
    const fsSource = `
      precision mediump float;
      uniform vec2 uResolution;
      uniform float uTime;

      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      void main() {
        vec2 st = gl_FragCoord.xy / uResolution.xy;

        // RGB shift for glitch
        float shift = sin(uTime * 2.0 + st.y * 10.0) * 0.02;
        float r = step(0.5, fract((st.x + shift) * 20.0 + uTime));
        float g = step(0.5, fract(st.x * 20.0));
        float b = step(0.5, fract((st.x - shift) * 20.0 - uTime));

        // Scanlines
        float scanline = sin(st.y * 800.0 + uTime * 10.0) * 0.1 + 0.9;

        // Random noise
        float noise = random(st + uTime) * 0.05;

        // Vivid colors
        vec3 color1 = vec3(1.0, 0.0, 0.5); // Pink
        vec3 color2 = vec3(0.0, 1.0, 1.0); // Cyan
        vec3 color3 = vec3(1.0, 1.0, 0.0); // Yellow

        vec3 color = mix(color1, color2, st.x);
        color = mix(color, color3, st.y);

        // Apply effects
        color.r *= r;
        color.g *= g;
        color.b *= b;
        color *= scanline;
        color += noise;

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // Compile shader
    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);

    // Create program
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
    }

    // Set up geometry
    const positions = new Float32Array([
      -1.0, -1.0,
       1.0, -1.0,
      -1.0,  1.0,
       1.0,  1.0,
    ]);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
    gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(vertexPosition);

    // Get uniform locations
    const uResolution = gl.getUniformLocation(shaderProgram, 'uResolution');
    const uTime = gl.getUniformLocation(shaderProgram, 'uTime');

    // Render loop
    let startTime = Date.now();
    function render() {
      const currentTime = (Date.now() - startTime) / 1000.0;

      gl.useProgram(shaderProgram);
      gl.uniform2f(uResolution, canvas.width, canvas.height);
      gl.uniform1f(uTime, currentTime);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
